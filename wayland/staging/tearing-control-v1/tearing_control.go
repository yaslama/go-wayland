// Generated by go-wayland-scanner
// https://github.com/yaslama/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/1.41/staging/tearing-control/tearing-control-v1.xml?ref_type=tags
//
// tearing_control_v1 Protocol Copyright:
//
// Copyright Â© 2021 Xaver Hugl
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package tearing_control

import "github.com/yaslama/go-wayland/wayland/client"

// TearingControlManagerInterfaceName is the name of the interface as it appears in the [client.Registry].
// It can be used to match the [client.RegistryGlobalEvent.Interface] in the
// [Registry.SetGlobalHandler] and can be used in [Registry.Bind] if this applies.
const TearingControlManagerInterfaceName = "wp_tearing_control_manager_v1"

// TearingControlManager : protocol for tearing control
//
// For some use cases like games or drawing tablets it can make sense to
// reduce latency by accepting tearing with the use of asynchronous page
// flips. This global is a factory interface, allowing clients to inform
// which type of presentation the content of their surfaces is suitable for.
//
// Graphics APIs like EGL or Vulkan, that manage the buffer queue and commits
// of a wl_surface themselves, are likely to be using this extension
// internally. If a client is using such an API for a wl_surface, it should
// not directly use this extension on that surface, to avoid raising a
// tearing_control_exists protocol error.
//
// Warning! The protocol described in this file is currently in the testing
// phase. Backward compatible changes may be added together with the
// corresponding interface version bump. Backward incompatible changes can
// only be done by creating a new major version of the extension.
type TearingControlManager struct {
	client.BaseProxy
}

// NewTearingControlManager : protocol for tearing control
//
// For some use cases like games or drawing tablets it can make sense to
// reduce latency by accepting tearing with the use of asynchronous page
// flips. This global is a factory interface, allowing clients to inform
// which type of presentation the content of their surfaces is suitable for.
//
// Graphics APIs like EGL or Vulkan, that manage the buffer queue and commits
// of a wl_surface themselves, are likely to be using this extension
// internally. If a client is using such an API for a wl_surface, it should
// not directly use this extension on that surface, to avoid raising a
// tearing_control_exists protocol error.
//
// Warning! The protocol described in this file is currently in the testing
// phase. Backward compatible changes may be added together with the
// corresponding interface version bump. Backward incompatible changes can
// only be done by creating a new major version of the extension.
func NewTearingControlManager(ctx *client.Context) *TearingControlManager {
	wpTearingControlManagerV1 := &TearingControlManager{}
	ctx.Register(wpTearingControlManagerV1)
	return wpTearingControlManagerV1
}

// Destroy : destroy tearing control factory object
//
// Destroy this tearing control factory object. Other objects, including
// wp_tearing_control_v1 objects created by this factory, are not affected
// by this request.
func (i *TearingControlManager) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// GetTearingControl : extend surface interface for tearing control
//
// Instantiate an interface extension for the given wl_surface to request
// asynchronous page flips for presentation.
//
// If the given wl_surface already has a wp_tearing_control_v1 object
// associated, the tearing_control_exists protocol error is raised.
func (i *TearingControlManager) GetTearingControl(surface *client.Surface) (*TearingControl, error) {
	id := NewTearingControl(i.Context())
	const opcode = 1
	const _reqBufLen = 8 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], surface.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return id, err
}

type TearingControlManagerError uint32

// TearingControlManagerError :
const (
	// TearingControlManagerErrorTearingControlExists : the surface already has a tearing object associated
	TearingControlManagerErrorTearingControlExists TearingControlManagerError = 0
)

func (e TearingControlManagerError) Name() string {
	switch e {
	case TearingControlManagerErrorTearingControlExists:
		return "tearing_control_exists"
	default:
		return ""
	}
}

func (e TearingControlManagerError) Value() string {
	switch e {
	case TearingControlManagerErrorTearingControlExists:
		return "0"
	default:
		return ""
	}
}

func (e TearingControlManagerError) String() string {
	return e.Name() + "=" + e.Value()
}

// TearingControlInterfaceName is the name of the interface as it appears in the [client.Registry].
// It can be used to match the [client.RegistryGlobalEvent.Interface] in the
// [Registry.SetGlobalHandler] and can be used in [Registry.Bind] if this applies.
const TearingControlInterfaceName = "wp_tearing_control_v1"

// TearingControl : per-surface tearing control interface
//
// An additional interface to a wl_surface object, which allows the client
// to hint to the compositor if the content on the surface is suitable for
// presentation with tearing.
// The default presentation hint is vsync. See presentation_hint for more
// details.
//
// If the associated wl_surface is destroyed, this object becomes inert and
// should be destroyed.
type TearingControl struct {
	client.BaseProxy
}

// NewTearingControl : per-surface tearing control interface
//
// An additional interface to a wl_surface object, which allows the client
// to hint to the compositor if the content on the surface is suitable for
// presentation with tearing.
// The default presentation hint is vsync. See presentation_hint for more
// details.
//
// If the associated wl_surface is destroyed, this object becomes inert and
// should be destroyed.
func NewTearingControl(ctx *client.Context) *TearingControl {
	wpTearingControlV1 := &TearingControl{}
	ctx.Register(wpTearingControlV1)
	return wpTearingControlV1
}

// SetPresentationHint : set presentation hint
//
// Set the presentation hint for the associated wl_surface. This state is
// double-buffered, see wl_surface.commit.
//
// The compositor is free to dynamically respect or ignore this hint based
// on various conditions like hardware capabilities, surface state and
// user preferences.
func (i *TearingControl) SetPresentationHint(hint uint32) error {
	const opcode = 0
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(hint))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Destroy : destroy tearing control object
//
// Destroy this surface tearing object and revert the presentation hint to
// vsync. The change will be applied on the next wl_surface.commit.
func (i *TearingControl) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type TearingControlPresentationHint uint32

// TearingControlPresentationHint : presentation hint values
//
// This enum provides information for if submitted frames from the client
// may be presented with tearing.
const (
	TearingControlPresentationHintVsync TearingControlPresentationHint = 0
	TearingControlPresentationHintAsync TearingControlPresentationHint = 1
)

func (e TearingControlPresentationHint) Name() string {
	switch e {
	case TearingControlPresentationHintVsync:
		return "vsync"
	case TearingControlPresentationHintAsync:
		return "async"
	default:
		return ""
	}
}

func (e TearingControlPresentationHint) Value() string {
	switch e {
	case TearingControlPresentationHintVsync:
		return "0"
	case TearingControlPresentationHintAsync:
		return "1"
	default:
		return ""
	}
}

func (e TearingControlPresentationHint) String() string {
	return e.Name() + "=" + e.Value()
}

// Generated by go-wayland-scanner
// https://github.com/yaslama/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/1.41/staging/ext-session-lock/ext-session-lock-v1.xml?ref_type=tags
//
// ext_session_lock_v1 Protocol Copyright:
//
// Copyright 2021 Isaac Freund
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package ext_session_lock

import "github.com/yaslama/go-wayland/wayland/client"

// ExtSessionLockManagerInterfaceName is the name of the interface as it appears in the [client.Registry].
// It can be used to match the [client.RegistryGlobalEvent.Interface] in the
// [Registry.SetGlobalHandler] and can be used in [Registry.Bind] if this applies.
const ExtSessionLockManagerInterfaceName = "ext_session_lock_manager_v1"

// ExtSessionLockManager : used to lock the session
//
// This interface is used to request that the session be locked.
type ExtSessionLockManager struct {
	client.BaseProxy
}

// NewExtSessionLockManager : used to lock the session
//
// This interface is used to request that the session be locked.
func NewExtSessionLockManager(ctx *client.Context) *ExtSessionLockManager {
	extSessionLockManagerV1 := &ExtSessionLockManager{}
	ctx.Register(extSessionLockManagerV1)
	return extSessionLockManagerV1
}

// Destroy : destroy the session lock manager object
//
// This informs the compositor that the session lock manager object will
// no longer be used. Existing objects created through this interface
// remain valid.
func (i *ExtSessionLockManager) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Lock : attempt to lock the session
//
// This request creates a session lock and asks the compositor to lock the
// session. The compositor will send either the ext_session_lock_v1.locked
// or ext_session_lock_v1.finished event on the created object in
// response to this request.
func (i *ExtSessionLockManager) Lock() (*ExtSessionLock, error) {
	id := NewExtSessionLock(i.Context())
	const opcode = 1
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return id, err
}

// ExtSessionLockInterfaceName is the name of the interface as it appears in the [client.Registry].
// It can be used to match the [client.RegistryGlobalEvent.Interface] in the
// [Registry.SetGlobalHandler] and can be used in [Registry.Bind] if this applies.
const ExtSessionLockInterfaceName = "ext_session_lock_v1"

// ExtSessionLock : manage lock state and create lock surfaces
//
// In response to the creation of this object the compositor must send
// either the locked or finished event.
//
// The locked event indicates that the session is locked. This means
// that the compositor must stop rendering and providing input to normal
// clients. Instead the compositor must blank all outputs with an opaque
// color such that their normal content is fully hidden.
//
// The only surfaces that should be rendered while the session is locked
// are the lock surfaces created through this interface and optionally,
// at the compositor's discretion, special privileged surfaces such as
// input methods or portions of desktop shell UIs.
//
// The locked event must not be sent until a new "locked" frame (either
// from a session lock surface or the compositor blanking the output) has
// been presented on all outputs and no security sensitive normal/unlocked
// content is possibly visible.
//
// The finished event should be sent immediately on creation of this
// object if the compositor decides that the locked event will not be sent.
//
// The compositor may wait for the client to create and render session lock
// surfaces before sending the locked event to avoid displaying intermediate
// blank frames. However, it must impose a reasonable time limit if
// waiting and send the locked event as soon as the hard requirements
// described above can be met if the time limit expires. Clients should
// immediately create lock surfaces for all outputs on creation of this
// object to make this possible.
//
// This behavior of the locked event is required in order to prevent
// possible race conditions with clients that wish to suspend the system
// or similar after locking the session. Without these semantics, clients
// triggering a suspend after receiving the locked event would race with
// the first "locked" frame being presented and normal/unlocked frames
// might be briefly visible as the system is resumed if the suspend
// operation wins the race.
//
// If the client dies while the session is locked, the compositor must not
// unlock the session in response. It is acceptable for the session to be
// permanently locked if this happens. The compositor may choose to continue
// to display the lock surfaces the client had mapped before it died or
// alternatively fall back to a solid color, this is compositor policy.
//
// Compositors may also allow a secure way to recover the session, the
// details of this are compositor policy. Compositors may allow a new
// client to create a ext_session_lock_v1 object and take responsibility
// for unlocking the session, they may even start a new lock client
// instance automatically.
type ExtSessionLock struct {
	client.BaseProxy
	lockedHandler   ExtSessionLockLockedHandlerFunc
	finishedHandler ExtSessionLockFinishedHandlerFunc
}

// NewExtSessionLock : manage lock state and create lock surfaces
//
// In response to the creation of this object the compositor must send
// either the locked or finished event.
//
// The locked event indicates that the session is locked. This means
// that the compositor must stop rendering and providing input to normal
// clients. Instead the compositor must blank all outputs with an opaque
// color such that their normal content is fully hidden.
//
// The only surfaces that should be rendered while the session is locked
// are the lock surfaces created through this interface and optionally,
// at the compositor's discretion, special privileged surfaces such as
// input methods or portions of desktop shell UIs.
//
// The locked event must not be sent until a new "locked" frame (either
// from a session lock surface or the compositor blanking the output) has
// been presented on all outputs and no security sensitive normal/unlocked
// content is possibly visible.
//
// The finished event should be sent immediately on creation of this
// object if the compositor decides that the locked event will not be sent.
//
// The compositor may wait for the client to create and render session lock
// surfaces before sending the locked event to avoid displaying intermediate
// blank frames. However, it must impose a reasonable time limit if
// waiting and send the locked event as soon as the hard requirements
// described above can be met if the time limit expires. Clients should
// immediately create lock surfaces for all outputs on creation of this
// object to make this possible.
//
// This behavior of the locked event is required in order to prevent
// possible race conditions with clients that wish to suspend the system
// or similar after locking the session. Without these semantics, clients
// triggering a suspend after receiving the locked event would race with
// the first "locked" frame being presented and normal/unlocked frames
// might be briefly visible as the system is resumed if the suspend
// operation wins the race.
//
// If the client dies while the session is locked, the compositor must not
// unlock the session in response. It is acceptable for the session to be
// permanently locked if this happens. The compositor may choose to continue
// to display the lock surfaces the client had mapped before it died or
// alternatively fall back to a solid color, this is compositor policy.
//
// Compositors may also allow a secure way to recover the session, the
// details of this are compositor policy. Compositors may allow a new
// client to create a ext_session_lock_v1 object and take responsibility
// for unlocking the session, they may even start a new lock client
// instance automatically.
func NewExtSessionLock(ctx *client.Context) *ExtSessionLock {
	extSessionLockV1 := &ExtSessionLock{}
	ctx.Register(extSessionLockV1)
	return extSessionLockV1
}

// Destroy : destroy the session lock
//
// This informs the compositor that the lock object will no longer be
// used. Existing objects created through this interface remain valid.
//
// After this request is made, lock surfaces created through this object
// should be destroyed by the client as they will no longer be used by
// the compositor.
//
// It is a protocol error to make this request if the locked event was
// sent, the unlock_and_destroy request must be used instead.
func (i *ExtSessionLock) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// GetLockSurface : create a lock surface for a given output
//
// The client is expected to create lock surfaces for all outputs
// currently present and any new outputs as they are advertised. These
// won't be displayed by the compositor unless the lock is successful
// and the locked event is sent.
//
// Providing a wl_surface which already has a role or already has a buffer
// attached or committed is a protocol error, as is attaching/committing
// a buffer before the first ext_session_lock_surface_v1.configure event.
//
// Attempting to create more than one lock surface for a given output
// is a duplicate_output protocol error.
func (i *ExtSessionLock) GetLockSurface(surface *client.Surface, output *client.Output) (*ExtSessionLockSurface, error) {
	id := NewExtSessionLockSurface(i.Context())
	const opcode = 1
	const _reqBufLen = 8 + 4 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], surface.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], output.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return id, err
}

// UnlockAndDestroy : unlock the session, destroying the object
//
// This request indicates that the session should be unlocked, for
// example because the user has entered their password and it has been
// verified by the client.
//
// This request also informs the compositor that the lock object will
// no longer be used and should be destroyed. Existing objects created
// through this interface remain valid.
//
// After this request is made, lock surfaces created through this object
// should be destroyed by the client as they will no longer be used by
// the compositor.
//
// It is a protocol error to make this request if the locked event has
// not been sent. In that case, the lock object must be destroyed using
// the destroy request.
//
// Note that a correct client that wishes to exit directly after unlocking
// the session must use the wl_display.sync request to ensure the server
// receives and processes the unlock_and_destroy request. Otherwise
// there is no guarantee that the server has unlocked the session due
// to the asynchronous nature of the Wayland protocol. For example,
// the server might terminate the client with a protocol error before
// it processes the unlock_and_destroy request.
func (i *ExtSessionLock) UnlockAndDestroy() error {
	defer i.Context().Unregister(i)
	const opcode = 2
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type ExtSessionLockError uint32

// ExtSessionLockError :
const (
	// ExtSessionLockErrorInvalidDestroy : attempted to destroy session lock while locked
	ExtSessionLockErrorInvalidDestroy ExtSessionLockError = 0
	// ExtSessionLockErrorInvalidUnlock : unlock requested but locked event was never sent
	ExtSessionLockErrorInvalidUnlock ExtSessionLockError = 1
	// ExtSessionLockErrorRole : given wl_surface already has a role
	ExtSessionLockErrorRole ExtSessionLockError = 2
	// ExtSessionLockErrorDuplicateOutput : given output already has a lock surface
	ExtSessionLockErrorDuplicateOutput ExtSessionLockError = 3
	// ExtSessionLockErrorAlreadyConstructed : given wl_surface has a buffer attached or committed
	ExtSessionLockErrorAlreadyConstructed ExtSessionLockError = 4
)

func (e ExtSessionLockError) Name() string {
	switch e {
	case ExtSessionLockErrorInvalidDestroy:
		return "invalid_destroy"
	case ExtSessionLockErrorInvalidUnlock:
		return "invalid_unlock"
	case ExtSessionLockErrorRole:
		return "role"
	case ExtSessionLockErrorDuplicateOutput:
		return "duplicate_output"
	case ExtSessionLockErrorAlreadyConstructed:
		return "already_constructed"
	default:
		return ""
	}
}

func (e ExtSessionLockError) Value() string {
	switch e {
	case ExtSessionLockErrorInvalidDestroy:
		return "0"
	case ExtSessionLockErrorInvalidUnlock:
		return "1"
	case ExtSessionLockErrorRole:
		return "2"
	case ExtSessionLockErrorDuplicateOutput:
		return "3"
	case ExtSessionLockErrorAlreadyConstructed:
		return "4"
	default:
		return ""
	}
}

func (e ExtSessionLockError) String() string {
	return e.Name() + "=" + e.Value()
}

// ExtSessionLockLockedEvent : session successfully locked
//
// This client is now responsible for displaying graphics while the
// session is locked and deciding when to unlock the session.
//
// The locked event must not be sent until a new "locked" frame has been
// presented on all outputs and no security sensitive normal/unlocked
// content is possibly visible.
//
// If this event is sent, making the destroy request is a protocol error,
// the lock object must be destroyed using the unlock_and_destroy request.
type ExtSessionLockLockedEvent struct{}
type ExtSessionLockLockedHandlerFunc func(ExtSessionLockLockedEvent)

// SetLockedHandler : sets handler for ExtSessionLockLockedEvent
func (i *ExtSessionLock) SetLockedHandler(f ExtSessionLockLockedHandlerFunc) {
	i.lockedHandler = f
}

// ExtSessionLockFinishedEvent : the session lock object should be destroyed
//
// The compositor has decided that the session lock should be destroyed
// as it will no longer be used by the compositor. Exactly when this
// event is sent is compositor policy, but it must never be sent more
// than once for a given session lock object.
//
// This might be sent because there is already another ext_session_lock_v1
// object held by a client, or the compositor has decided to deny the
// request to lock the session for some other reason. This might also
// be sent because the compositor implements some alternative, secure
// way to authenticate and unlock the session.
//
// The finished event should be sent immediately on creation of this
// object if the compositor decides that the locked event will not
// be sent.
//
// If the locked event is sent on creation of this object the finished
// event may still be sent at some later time in this object's
// lifetime. This is compositor policy.
//
// Upon receiving this event, the client should make either the destroy
// request or the unlock_and_destroy request, depending on whether or
// not the locked event was received on this object.
type ExtSessionLockFinishedEvent struct{}
type ExtSessionLockFinishedHandlerFunc func(ExtSessionLockFinishedEvent)

// SetFinishedHandler : sets handler for ExtSessionLockFinishedEvent
func (i *ExtSessionLock) SetFinishedHandler(f ExtSessionLockFinishedHandlerFunc) {
	i.finishedHandler = f
}

func (i *ExtSessionLock) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.lockedHandler == nil {
			return
		}
		var e ExtSessionLockLockedEvent

		i.lockedHandler(e)
	case 1:
		if i.finishedHandler == nil {
			return
		}
		var e ExtSessionLockFinishedEvent

		i.finishedHandler(e)
	}
}

// ExtSessionLockSurfaceInterfaceName is the name of the interface as it appears in the [client.Registry].
// It can be used to match the [client.RegistryGlobalEvent.Interface] in the
// [Registry.SetGlobalHandler] and can be used in [Registry.Bind] if this applies.
const ExtSessionLockSurfaceInterfaceName = "ext_session_lock_surface_v1"

// ExtSessionLockSurface : a surface displayed while the session is locked
//
// The client may use lock surfaces to display a screensaver, render a
// dialog to enter a password and unlock the session, or however else it
// sees fit.
//
// On binding this interface the compositor will immediately send the
// first configure event. After making the ack_configure request in
// response to this event the client should attach and commit the first
// buffer. Committing the surface before acking the first configure is a
// protocol error. Committing the surface with a null buffer at any time
// is a protocol error.
//
// The compositor is free to handle keyboard/pointer focus for lock
// surfaces however it chooses. A reasonable way to do this would be to
// give the first lock surface created keyboard focus and change keyboard
// focus if the user clicks on other surfaces.
type ExtSessionLockSurface struct {
	client.BaseProxy
	configureHandler ExtSessionLockSurfaceConfigureHandlerFunc
}

// NewExtSessionLockSurface : a surface displayed while the session is locked
//
// The client may use lock surfaces to display a screensaver, render a
// dialog to enter a password and unlock the session, or however else it
// sees fit.
//
// On binding this interface the compositor will immediately send the
// first configure event. After making the ack_configure request in
// response to this event the client should attach and commit the first
// buffer. Committing the surface before acking the first configure is a
// protocol error. Committing the surface with a null buffer at any time
// is a protocol error.
//
// The compositor is free to handle keyboard/pointer focus for lock
// surfaces however it chooses. A reasonable way to do this would be to
// give the first lock surface created keyboard focus and change keyboard
// focus if the user clicks on other surfaces.
func NewExtSessionLockSurface(ctx *client.Context) *ExtSessionLockSurface {
	extSessionLockSurfaceV1 := &ExtSessionLockSurface{}
	ctx.Register(extSessionLockSurfaceV1)
	return extSessionLockSurfaceV1
}

// Destroy : destroy the lock surface object
//
// This informs the compositor that the lock surface object will no
// longer be used.
//
// It is recommended for a lock client to destroy lock surfaces if
// their corresponding wl_output global is removed.
//
// If a lock surface on an active output is destroyed before the
// ext_session_lock_v1.unlock_and_destroy event is sent, the compositor
// must fall back to rendering a solid color.
func (i *ExtSessionLockSurface) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// AckConfigure : ack a configure event
//
// When a configure event is received, if a client commits the surface
// in response to the configure event, then the client must make an
// ack_configure request sometime before the commit request, passing
// along the serial of the configure event.
//
// If the client receives multiple configure events before it can
// respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending an
// ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing,
// but only the last request sent before a commit indicates which
// configure event the client really is responding to.
//
// Sending an ack_configure request consumes the configure event
// referenced by the given serial, as well as all older configure events
// sent on this object.
//
// It is a protocol error to issue multiple ack_configure requests
// referencing the same configure event or to issue an ack_configure
// request referencing a configure event older than the last configure
// event acked for a given lock surface.
//
//	serial: serial from the configure event
func (i *ExtSessionLockSurface) AckConfigure(serial uint32) error {
	const opcode = 1
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type ExtSessionLockSurfaceError uint32

// ExtSessionLockSurfaceError :
const (
	// ExtSessionLockSurfaceErrorCommitBeforeFirstAck : surface committed before first ack_configure request
	ExtSessionLockSurfaceErrorCommitBeforeFirstAck ExtSessionLockSurfaceError = 0
	// ExtSessionLockSurfaceErrorNullBuffer : surface committed with a null buffer
	ExtSessionLockSurfaceErrorNullBuffer ExtSessionLockSurfaceError = 1
	// ExtSessionLockSurfaceErrorDimensionsMismatch : failed to match ack'd width/height
	ExtSessionLockSurfaceErrorDimensionsMismatch ExtSessionLockSurfaceError = 2
	// ExtSessionLockSurfaceErrorInvalidSerial : serial provided in ack_configure is invalid
	ExtSessionLockSurfaceErrorInvalidSerial ExtSessionLockSurfaceError = 3
)

func (e ExtSessionLockSurfaceError) Name() string {
	switch e {
	case ExtSessionLockSurfaceErrorCommitBeforeFirstAck:
		return "commit_before_first_ack"
	case ExtSessionLockSurfaceErrorNullBuffer:
		return "null_buffer"
	case ExtSessionLockSurfaceErrorDimensionsMismatch:
		return "dimensions_mismatch"
	case ExtSessionLockSurfaceErrorInvalidSerial:
		return "invalid_serial"
	default:
		return ""
	}
}

func (e ExtSessionLockSurfaceError) Value() string {
	switch e {
	case ExtSessionLockSurfaceErrorCommitBeforeFirstAck:
		return "0"
	case ExtSessionLockSurfaceErrorNullBuffer:
		return "1"
	case ExtSessionLockSurfaceErrorDimensionsMismatch:
		return "2"
	case ExtSessionLockSurfaceErrorInvalidSerial:
		return "3"
	default:
		return ""
	}
}

func (e ExtSessionLockSurfaceError) String() string {
	return e.Name() + "=" + e.Value()
}

// ExtSessionLockSurfaceConfigureEvent : the client should resize its surface
//
// This event is sent once on binding the interface and may be sent again
// at the compositor's discretion, for example if output geometry changes.
//
// The width and height are in surface-local coordinates and are exact
// requirements. Failing to match these surface dimensions in the next
// commit after acking a configure is a protocol error.
type ExtSessionLockSurfaceConfigureEvent struct {
	Serial uint32
	Width  uint32
	Height uint32
}
type ExtSessionLockSurfaceConfigureHandlerFunc func(ExtSessionLockSurfaceConfigureEvent)

// SetConfigureHandler : sets handler for ExtSessionLockSurfaceConfigureEvent
func (i *ExtSessionLockSurface) SetConfigureHandler(f ExtSessionLockSurfaceConfigureHandlerFunc) {
	i.configureHandler = f
}

func (i *ExtSessionLockSurface) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.configureHandler == nil {
			return
		}
		var e ExtSessionLockSurfaceConfigureEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Width = client.Uint32(data[l : l+4])
		l += 4
		e.Height = client.Uint32(data[l : l+4])
		l += 4

		i.configureHandler(e)
	}
}
